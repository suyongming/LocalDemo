一、并发基础问题
    1.什么是多线程并发和并行？
        :先说并行: 并行是因为多核处理器,所以是多个线程一起执行.
        :并发：微观上所有进程和线程是走走停停的，宏观上都在运行，
        不是绝对意义上的“同时发生。


    2.什么是线程安全问题？
        :原子性、可见性和有序性。


    3.什么是共享变量的内存可见性问题？
        :每个线程都有一个自己的内存空间，当线程启动的时候把变量从共享内存拷贝一份到私有内存，
        :在这个变量更改后，需要push到共享内存(Sharing Data Memory)，其他线程才能读取到变量新的值；


    4.什么是Java中原子性操作？
        :即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。


    5.什么是Java中的CAS操作,AtomicLong实现原理？
        ：compare and set的缩写
        ：CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。
        ：当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做
        ：指在set之前先比较该值有没有变化，只有在没变的情况下才对其赋值。
        CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”

            <ABA问题>
            CAS操作容易导致ABA问题,也就是在做a++之间，a可能被多个线程修改过了，只不过回到了最初的值，
            这时CAS会认为a的值没有变。a在外面逛了一圈回来，你能保证它没有做任何坏事，不能！！
            也许它讨闲，把b的值减了一下，把c的值加了一下等等。

        Unsafe.getAndAddLong
        public final boolean compareAndSet(long expect, long update) {
        　　　　//valueOffSet为内存中的值，expect的值为旧的预期值，
               //该线程执行getAndIncrement()函数时，通过get()获取的当时的变量值
        　　　 //update=expect+1
        　　　 // 只有valueOffset=expect时才会把变量的值设置为update，设置成功返回true，否则返回false
        　 　　return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
        }


    6.什么是Java指令重排序？
        好处：不影响单线程程序正确性的情况下提升程序的性能。
        坏处:多核处理器的环境下，执行顺序可能是没有保障的：编译器可能改变两个操作的先后顺序；
           对多线程程序的正确性产生影响，即它可能导致线程安全问题。
        重排序的潜在来源:
            1.包括编译器（在Java平发到台中这基本上指JIT编译器）
            2.处理器和存储子系统（包括写缓冲器、高速缓存）


    7.Java中Synchronized关键字的内存语义是什么？



    8.Java中Volatile关键字的内存语义是什么？
        当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。
        当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。


    什么是伪共享,为何会出现，以及如何避免？



    什么是可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？

二、Synchronized问题
    Synchronized 用过吗，说说原理是什么？
        Synchronized 是由 JVM 实现的一种实现互斥同步的一种方式

        Synchronized 是由 JVM 实现的一种实现互斥同步的一种方式，
        如果你查看被 Synchronized 修饰过的程序块编译后的字节码，
        会发现，被 Synchronized 修饰过的程序块，
        在编译前后被编译器生成了 monitorenter 和 monitorexit 两个字节码指令。

        这两个指令是什么意思呢？

        在虚拟机执行到 monitorenter 指令时，首先要尝试获取对象的锁：

        如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，
        把锁的计数器 +1；当执行 monitorexit 指令时将锁计数器 -1；
        当计数器为 0 时，锁就被释放了。

        如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

        Java 中 Synchronize 通过在对象头设置标记，达到了获取锁和释放锁的目的。

    刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？

    什么是可重入性，为什么说 Synchronized 是可重入锁？

    JVM 对 Java 的原生锁做了哪些优化？

    为什么说 Synchronized 是非公平锁？

    什么是锁消除和锁粗化？

    为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？

    乐观锁一定就是好的吗？


三、可重入锁ReentrantLock问题
    跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？

    再谈谈 AQS 框架是什么？

    请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同点

    ReentrantLock 是如何实现可重入性的？

    除了 ReentrantLock，你还接触过 JUC 中的哪些并发工具？

    请谈谈 ReadWriteLock 和 StampedLock。

    如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。

    CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？

四、线程池如何实现的
    Java 中的线程池是如何实现的？

    创建线程池的几个核心构造参数？

    线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？

    既然提到可以通过配置不同参数创建出不同的线程池，那么 Java 中默认实现好的线程池又有哪些呢？请比较它们的异同。

    如何在 Java 线程池中提交线程？

五、java内存模型相关问题
    什么是 Java 的内存模型，Java 中各个线程是怎么彼此看到对方的变量的？

    请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？

    既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？


     :不是的！因为
     :volatile的可见性只能保证 线程之间的相对可见，而不是最新可见。
     :真正的最新可见是，如果有线程正在读取中，其他线程不能修改。

    请对比下 volatile 对比 Synchronized 的异同。

    请谈谈 ThreadLocal 是怎么解决并发安全的？

    很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？



-- 阿里面试-------------------------------------------------------------------------
1.JVM 对 Java 的原生锁做了哪些优化？

2.为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？
CAS乐观锁策略（简单理解就是，永远以主存中的内容为参考）.

3.乐观锁一定就是好的吗？

4.跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？

5.如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。

6.很多人都说要慎用 Thread Local，谈谈你的理解，使用Thread Local 需要注意些什么？






