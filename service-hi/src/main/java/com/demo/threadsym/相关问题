一、并发基础问题
    1.什么是多线程并发和并行？
        :先说并行: 并行是因为多核处理器,所以是多个线程一起执行.
        :并发：微观上所有进程和线程是走走停停的，宏观上都在运行，
        不是绝对意义上的“同时发生。


    2.什么是线程安全问题？
        :原子性、可见性和有序性。


    3.什么是共享变量的内存可见性问题？
        :每个线程都有一个自己的内存空间，当线程启动的时候把变量从共享内存拷贝一份到私有内存，
        :在这个变量更改后，需要push到共享内存(Sharing Data Memory)，其他线程才能读取到变量新的值；


    4.什么是Java中原子性操作？
        :即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。


    5.什么是Java中的CAS操作？
        CAS乐观锁策略（简单理解就是，永远以主存中的内容为参考）.

        CAS:它涉及到三个操作数：内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。
        这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，
        如不一样则表示期间此内存值已经被别的线程更改过，
        舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。

            <ABA问题>
            CAS操作容易导致ABA问题,也就是在做a++之间，a可能被多个线程修改过了，只不过回到了最初的值，
            这时CAS会认为a的值没有变。a在外面逛了一圈回来，你能保证它没有做任何坏事，不能！！
            也许它讨闲，把b的值减了一下，把c的值加了一下等等。

            从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。
            这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，
            并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。


    6.什么是Java指令重排序？
        好处：不影响单线程程序正确性的情况下提升程序的性能。
        坏处:多核处理器的环境下，执行顺序可能是没有保障的：编译器可能改变两个操作的先后顺序；
           对多线程程序的正确性产生影响，即它可能导致线程安全问题。
        重排序的潜在来源:
            1.包括编译器（在Java平发到台中这基本上指JIT编译器）
            2.处理器和存储子系统（包括写缓冲器、高速缓存）


    7.Java中Synchronized关键字的内存语义是什么？



    8.Java中Volatile关键字的内存语义是什么?
        当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。
        当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。


    9.什么是伪共享,为何会出现，以及如何避免？



    10.什么是可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？



二、Synchronized问题

    Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；
    Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；
    Wait Set：哪些调用wait方法被阻塞的线程被放置在这里；
    OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck；
    Owner：当前已经获取到所资源的线程被称为Owner；
    !Owner：当前释放锁的线程。

    1.Synchronized 用过吗，说说原理是什么？
        Synchronized 是由 JVM 实现的一种实现互斥同步的一种方式

        Synchronized 是由 JVM 实现的一种实现互斥同步的一种方式，
        如果你查看被 Synchronized 修饰过的程序块编译后的字节码，
        会发现，被 Synchronized 修饰过的程序块，
        在编译前后被编译器生成了 monitorenter 和 monitorexit 两个字节码指令。

        这两个指令是什么意思呢？

        在虚拟机执行到 monitorenter 指令时，首先要尝试获取对象的锁：

        如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，
        把锁的计数器 +1；当执行 monitorexit 指令时将锁计数器 -1；
        当计数器为 0 时，锁就被释放了。

        如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

        Java 中 Synchronize 通过在对象头设置标记，达到了获取锁和释放锁的目的。

    2.刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？
        对象头中的markword数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，
        它的最后2bit是锁状态标志位



    3.什么是可重入性，为什么说 Synchronized 是可重入锁？

    4.JVM 对 Java 的原生锁做了哪些优化？

    5.为什么说 Synchronized 是非公平锁？
        非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，
        任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象。

    6.什么是锁消除和锁粗化？
        	锁消除：指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。主要根据逃逸分析。

        程序员怎么会在明知道不存在数据竞争的情况下使用同步呢？很多不是程序员自己加入的。

        	锁粗化：原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作在循环体内，
        	频繁地进行互斥同步操作也会导致不必要的性能损耗。

        锁粗化就是增大锁的作用域。

    为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？

    乐观锁一定就是好的吗？


三、可重入锁ReentrantLock问题
    跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？

    再谈谈 AQS 框架是什么？

    请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同点

    ReentrantLock 是如何实现可重入性的？

    除了 ReentrantLock，你还接触过 JUC 中的哪些并发工具？

    请谈谈 ReadWriteLock 和 StampedLock。

    如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。

    CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？

四、线程池如何实现的
    Java 中的线程池是如何实现的？

    创建线程池的几个核心构造参数？

    线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？

    既然提到可以通过配置不同参数创建出不同的线程池，那么 Java 中默认实现好的线程池又有哪些呢？请比较它们的异同。

    如何在 Java 线程池中提交线程？

五、java内存模型相关问题
    什么是 Java 的内存模型，Java 中各个线程是怎么彼此看到对方的变量的？

    请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？

    既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？


     :不是的！因为
     :volatile的可见性只能保证 线程之间的相对可见，而不是最新可见。
     :真正的最新可见是，如果有线程正在读取中，其他线程不能修改。

    请对比下 volatile 对比 Synchronized 的异同。

    请谈谈 ThreadLocal 是怎么解决并发安全的？

    很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？



-- 阿里面试-------------------------------------------------------------------------
1.JVM 对 Java 的原生锁做了哪些优化？

2.为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？
    CAS乐观锁策略（简单理解就是，永远以主存中的内容为参考）.

    CAS:它涉及到三个操作数：内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。
    这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，
    如不一样则表示期间此内存值已经被别的线程更改过，
    舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。


3.乐观锁一定就是好的吗？

4.跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？

5.如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。

6.很多人都说要慎用 Thread Local，谈谈你的理解，使用Thread Local 需要注意些什么？

    每个线程对应主内存之间的一层内存空间，它其实就是Thread Local
    宏观上看是 多对一的关系。
    当前线程从主内存读取后变量后 会在








