0.Thread和 Runnable的区别===================================================================
首先，java只能单继承，因此如果是采用继承Thread的方法，
那么在以后进行代码重构的时候可能会遇到问题，因为你无法继承别的类了。
其次，如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。

继承Thread实现和 实现Runnable的区别
继承Thread实现的模式是  定义多个线程,各自完成各自的任务.
实现Runnable实现的模式是  定义多个线程,实现一个任务.
--------------------------------------------------------------------------------------------

Thread myThread = new MyThread();
1.myThread.start():=========================================================================
        myThread.start();
 1）通过 JVM 告诉操作系统创建线程 Thread

 2）操作系统开辟内存并调用系统函数创建 Thread 线程对象

 3）操作系统对 Thread 线程对象进行调度，以确定执行时机

 4）Thread 在操作系统中被成功执行
------------------------------------------------------------------------------------

2.myThread.run():===================================================================
如果在 run 类中直接调用 myThread.run()方法，就不是异步执行了
，而是同步执行，此线程对象不交给底层的“线程规划器”处理，（线程规划器？尼玛难道不是资源调度器？）
而是由 main 主线程来调用，也就是必须等 run()方法中的代码执行完毕后才可以执行后面的代码。

-------------------------------------------------------------------------------------

3.getId():===========================================================================
    获取线程的唯一标识。
-------------------------------------------------------------------------------------

4.currentThread()====================================================================
    currentThread()方法可以返回代码段正在被哪个线程调用。
-------------------------------------------------------------------------------------

5. isAlive()=========================================================================
    判断当前线程是否存活
-------------------------------------------------------------------------------------

=====================================================================================
6. sleep()方法
    sleep(long millis) 让线程休眠
--------------------------------------------------------------------------------------


7.Thread.yield():=================================================================
如果你觉得一个线程
不是那么重要，
优先级非常低，
害怕它会占用太多的CPU资源，
那么可以在适当的时候调用Thread.yield()放弃当前的 cpu 资源，
让其它任务去占用 cpu 执行时间，
放弃时间不确定，有可能刚放弃又马上获得时间片。
-------------------------------------------------------------------


8. StackTraceElement[] getStackTrace()==========================================================
返回一个表示该线程堆栈跟踪元素数组。如果该线程尚未启动或已经终止，则该 方法将返回一个 零长度数组。
如果返回的数组不是零长度的，则第一个元素表示堆栈顶，它是该数组中最新的方法调用。
最后一个元素表示堆栈底，是该数组中最旧的方法调用。
---------------------------------------------------------------------------------------------------


9. static Map<Thread, StackTraceElement[] > getAllStackTraces()方法==================================
    返回所有活动线程的堆栈跟踪的一个映射。映射键是线程，值是一个 StackTraceElement数组 ,
 该数组表示相应 Thread 的堆栈存储。

    调用该方法的同时，线程可能也在执行。每个线程的堆栈跟踪仅代表一个快照。
--------------------------------------------------------------------------------------------------

10. 设置线程优先级======================================================================================
    在操作系统中，线程可以划分优先级，高优先级的线程获得更多的时间片。再 java 中，线程的优先级分为1~10的等级，
如果优先级小于1或者大于10，会抛出 IllegalArgumentException()

    继承性：A 启动线程 B，则 B 线程的优先级与 A 一样。

    不确定性：线程优先级与执行顺序无关，这两者没有依赖关系，它们具有不确定性、随机性

    用法：thread.setPriority(1);
———————————————————————————————————————————————————————————————————————————————————————————————————————


11. setDaemon() 设置守护线程=================================================================
    Java 中有两种行程：一种是用户线程，也称非守护线程；另一种是守护线程。

    守护线程：一种特殊的线程，当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程时垃圾回收线程，
当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。

    用法： thread.setDaemon(true);
————————————————————————————————————————————————————————————————————————————————————————————————


myThread.join():=================================================================
在某些情况下，主线程创建并启动了子线程，
如果子线程中需要进行大量的耗时运算，
主线程往往将早于子线程结束之前结束，
如果主线程想等待子线程执行完毕后，
获得子线程中的处理完的某个数据，
就要用到join方法了，方法join（）的作用是等待线程对象呗销毁。

曾经做过一个联通的增值业务项目，其中有一个业务需要给联通方暴漏接口，
他们调用我们的接口，我们进行业务处理后，再返回结果，接口要求是同步的，实时返回。
如果异步的就可以用消息队列解决了，吧整个业务逻辑中比较费时间的都放在了子线程中运行，
子线程跑完后在交由主线程返回结果。当时用的是java中的栅栏 CyclicBarrier ，现在想想用join也是可以实现的。
------------------------------------------------------------------------------------------
