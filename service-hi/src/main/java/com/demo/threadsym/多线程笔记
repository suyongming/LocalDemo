Thread.yield():=================================================================
如果你觉得一个线程
不是那么重要，
优先级非常低，
害怕它会占用太多的CPU资源，
那么可以在适当的时候调用Thread.yield()，给予其他重要线程更多的工作机会。
-------------------------------------------------------------------

Thread.currentThread.join():=================================================================
在某些情况下，主线程创建并启动了子线程，
如果子线程中需要进行大量的耗时运算，
主线程往往将早于子线程结束之前结束，
如果主线程想等待子线程执行完毕后，
获得子线程中的处理完的某个数据，
就要用到join方法了，方法join（）的作用是等待线程对象呗销毁。

曾经做过一个联通的增值业务项目，其中有一个业务需要给联通方暴漏接口，
他们调用我们的接口，我们进行业务处理后，再返回结果，接口要求是同步的，实时返回。
如果异步的就可以用消息队列解决了，吧整个业务逻辑中比较费时间的都放在了子线程中运行，
子线程跑完后在交由主线程返回结果。当时用的是java中的栅栏 CyclicBarrier ，现在想想用join也是可以实现的。
------------------------------------------------------------------------------------------

上下文切换:=================================================================
从Java的角度来看，一个线程的生命周期状态在RUNNABLE状态与非RUNNABLE状态之间切换的过程就是一个上下文切换的过程。
当一个线程的生命周期状态由RUNNABLE转换为非RUNNABLE时，我们称这个线程被暂停，此时操作系统会保存相应线程的上下文。
而一个线程的生命周期状态由非RUNNABLE状态进入RUNNABLE状态时，我们就称这个线程被唤醒。
一个线程被唤醒仅代表该线程获得了一个继续运行的机会，而并不代表其立刻可以占用处理器运行。
当被唤醒的线程被操作系统选中占用处理器继续其运行的时候，操作系统会恢复之前为该线程保存的上下文，以便其在此基础上进展。
 按照导致上下文切换的因素划分，可以将上下文切换分为自发性上下文切换和非自发性上下文切换。
自发性上下文切换指线程由于其自身因素导致的切出。

<自发性上下文切换>：
Thread.sleep(long mills)
Object.wait()/wait(long timeout)/wait(long timeout, int nanos)
Thread.yield()--这个方法可能会也可能不会引起上下文切换，这取决于线程调度器
Thread.join()/join(long timeout)
LockSupport.park()

<非自发性上下文切换>：
线程的时间片用完或者有一个比当前线程优先级更高的线程需要运行。
此外，JVM的垃圾回收动作也可能导致非自发性上下文切换。
这是因为垃圾回收器在执行垃圾回收的过程中可能需要暂停所有应用线程才能完成其工作。
-------------------------------------------------------------------------


线程的活性故障====================================================
死锁：死锁是指两个或两个以上的线程在执行过程中，
因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

活锁：线程没有被阻塞，但由于某些条件没有满足，导致一直处于尝试-失败-尝试-失败的过程。
处于活锁的实体是在不断的改变状态，活锁有可能自行解开。自旋锁?

饥饿：线程一直无法获得其所需的资源而导致其任务一直无法进展。
(在失败队列中的线程们一但没有抢过 资源调度器非公平情况下的插队线程将会出现饥饿状态。)

-------------------------------------------------------------------
<排他性资源>:
一次只能够被一个线程占用的资源被称为排他性资源。
如处理器、数据库连接、文件等。

<资源争用>:
在一个线程占用一个排他性资源进行访问而未释放的时候，其他线程‘试图’访问该资源的现象。

<资源的调度>:
在多个线程申请同一个排他性资源的情况下，决定哪个线程会被授予该资源的独占权的过程。
资源调度策略的一个常见特性就是公平性。

<资源调度器>:
1.内部维护一个等待队列，申请失败的线程会被存入该队列。
2.当资源被持有线程释放时，等待队列中的一个线程会被选中并被唤醒而获得再次申请资源的机会。
3.被唤醒的线程如果申请到资源的独占权，那么该线程会从等待队列中移除；
否则，该线程仍然会停留在等待队列中等待再次申请的机会，即该线程会再次被暂停。

公平(FIFO):公平的调度策略不允许插队现象的出现。
只有在资源未被其他任何线程占用，并且等待队列为空的情况下，
资源的申请者才被允许<抢占>相应资源的独占权。

非公平:允许插队现象，即一个线程释放对资源的独占权时，
等待队列中的一个线程会被唤醒来再次申请相应的资源，
而在这个过程中另外一个申请该资源的活跃线程（生命周期状态为RUNNABLE状态）
可以与这个被唤醒的线程共同参与相应资源的抢占。
这时如果失败队列又一次失败，将有可能出现出现饥饿现象。
---------------------------------------------------------------------------------

调度器公平和非公平的区别:===========================================================
既然非公平调度策略有可能导致饥饿线程，那为什么还要提出这种调度策略呢？
这是因为，在公平调度策略中，当一个线程在申请资源时，
只要等待队列不为空，即存在在它之前的申请者，
那么这个线程一定会被暂停并加入等待队列，这就必然会出现线程的上下文切换。--------影响吞度量
而在非公平调度策略中，资源的持有线程释放资源的时候，等待队列中的一个线程会被唤醒，
新来的线程也会参与到资源的竞争当中。如果新来的线程申请到了资源，那么它就无需进行上下文切换。
如果这个新来的线程占用该资源的时间不长，那么它甚至有可能在被唤醒的线程继续其运行前释放资源，
从而不影响该被唤醒的线程申请资源。它可能会减少上下文切换的次数，从而提高吞吐率。
----------------------------------------------------------------------------------

小记:要在线程间共享long与double字段时，必须在synchronized中操作，或是声明为volatile。
因为JVM32位 高位低操作。

线程安全问题概括来说表现为3个方面：原子性、可见性和有序性。:=============================
    <原子性>:
    原子的字面意思是不可分割的。
在生活中一个原子操作的例子，人们从ATM机提取现金：尽管从ATM软件的角度来说，
一笔取款交易涉及扣减户账户余额、吐出钞票、新增交易记录等一系列操作，
但是从用户的角度来看ATM取款就是一个原子操作。

Java中有两种方式来实现原子性。一种是使用锁（Lock）。
锁具有排他性，即它能够保障一个共享变量在任意时刻只能够被一个线程访问。
消除了多个线程在同一时刻访问同一个共享变量而导致干扰与冲突的可能，即消除了竞态。

另一种是利用处理器提供的专门CAS（Compare-and-Swap）指令。
CAS指令实现原子性的方式与锁实现原子性的方式实质上是相同的，
差别在于锁通常是在软件这一层次实现的，
而CAS是直接在硬件（处理器和内存）这一层次实现的，它可以被看作“硬件锁”。
----------------------------------------------------------------------

<可见性>:=============================================================
    在多线程环境下，一个线程对某个共享变量进行更新之后，
    后续访问该变量的线程可能无法立刻读取到这个更新的结果，
    甚至永远也无法读取到这个更新的结果。
    这就是线程安全问题的另外一个表现形式：可见性。

寄存器是操作数据的地方，存储器是存放数据的地方。

可见性问题产生剖析:
可见性问题与计算机的存储系统有关。程序中的变量可能会被分配到寄存器而不是主内存中进行存储。
每个处理器都有其寄存器，而一个处理器无法读取另外一个处理器上的寄存器中的内容。
因此，如果两个线程分别运行在不同的处理器上，而这两个线程所共享的变量却被分配到寄存器上进行存储，那么可见性问题就会产生。
另外，即便某个共享变量是被分配到主内存中进行存储的，也不能保证该变量的可见性。
这是因为处理器对主内存的访问并不是直接访问，而是通过其高速缓存子系统进行的。
如果高速缓存子系统中的内容没有及时更新，那么处理器读取到的值仍然有可能是一个旧值，这同样会导致可见性问题。

在java中保如何持可见性:volatile

处理器缓存 = 处理器对主内存的缓存(暂称)
volatile关键字修饰的变量会使相应的处理器执行冲刷处理器缓存的动作，从而保障了可见性。

共享变量：
    相对新值:一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值。
    最新值:读取这个共享变量的线程在读取并使用该变量的时候，而且其他线程无法更新该变量的值，这个时刻称之为 最新值。

可见性的保障仅仅意味着一个线程能够读取到共享变量的相对新值，而不能保障该线程能够读取到相应变量的最新值
(volatile仅仅保证读取的相对新值，而不是最新值，因为在接下来的执行过程中可能会被其他线程又改变过)

针对原子性，Java语言规范中还定义了两条与线程的启动和停止有关的规范：
父线程在启动子线程之前对共享变量的更新对于子线程来说是可见的；
一个线程终止后该线程对共享变量的更新对于调用该线程的join方法的线程而言是可见的。
---------------------------------------------------------------------------------------------

<有序性>:======================================================================================
在进一步介绍有序性这个概念之前，需要先了解重排序的概念.
重排序:







