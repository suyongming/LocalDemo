Thread.yield():=================================================================
如果你觉得一个线程
不是那么重要，
优先级非常低，
害怕它会占用太多的CPU资源，
那么可以在适当的时候调用Thread.yield()，给予其他重要线程更多的工作机会。
-------------------------------------------------------------------

Thread.currentThread.join():=================================================================
在某些情况下，主线程创建并启动了子线程，
如果子线程中需要进行大量的耗时运算，
主线程往往将早于子线程结束之前结束，
如果主线程想等待子线程执行完毕后，
获得子线程中的处理完的某个数据，
就要用到join方法了，方法join（）的作用是等待线程对象呗销毁。

曾经做过一个联通的增值业务项目，其中有一个业务需要给联通方暴漏接口，
他们调用我们的接口，我们进行业务处理后，再返回结果，接口要求是同步的，实时返回。
如果异步的就可以用消息队列解决了，吧整个业务逻辑中比较费时间的都放在了子线程中运行，
子线程跑完后在交由主线程返回结果。当时用的是java中的栅栏 CyclicBarrier ，现在想想用join也是可以实现的。
------------------------------------------------------------------------------------------

上下文切换:=================================================================
从Java的角度来看，一个线程的生命周期状态在RUNNABLE状态与非RUNNABLE状态之间切换的过程就是一个上下文切换的过程。
当一个线程的生命周期状态由RUNNABLE转换为非RUNNABLE时，我们称这个线程被暂停，此时操作系统会保存相应线程的上下文。
而一个线程的生命周期状态由非RUNNABLE状态进入RUNNABLE状态时，我们就称这个线程被唤醒。
一个线程被唤醒仅代表该线程获得了一个继续运行的机会，而并不代表其立刻可以占用处理器运行。
当被唤醒的线程被操作系统选中占用处理器继续其运行的时候，操作系统会恢复之前为该线程保存的上下文，以便其在此基础上进展。
 按照导致上下文切换的因素划分，可以将上下文切换分为自发性上下文切换和非自发性上下文切换。
自发性上下文切换指线程由于其自身因素导致的切出。

<自发性上下文切换>：
Thread.sleep(long mills)
Object.wait()/wait(long timeout)/wait(long timeout, int nanos)
Thread.yield()--这个方法可能会也可能不会引起上下文切换，这取决于线程调度器
Thread.join()/join(long timeout)
LockSupport.park()

<非自发性上下文切换>：
线程的时间片用完或者有一个比当前线程优先级更高的线程需要运行。
此外，JVM的垃圾回收动作也可能导致非自发性上下文切换。
这是因为垃圾回收器在执行垃圾回收的过程中可能需要暂停所有应用线程才能完成其工作。
-------------------------------------------------------------------------


线程的活性故障====================================================
死锁：死锁是指两个或两个以上的线程在执行过程中，
因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

活锁：线程没有被阻塞，但由于某些条件没有满足，导致一直处于尝试-失败-尝试-失败的过程。
处于活锁的实体是在不断的改变状态，活锁有可能自行解开。自旋锁?

饥饿：线程一直无法获得其所需的资源而导致其任务一直无法进展。
(在失败队列中的线程们一但没有抢过 资源调度器非公平情况下的插队线程将会出现饥饿状态。)

-------------------------------------------------------------------
<排他性资源>:
一次只能够被一个线程占用的资源被称为排他性资源。
如处理器、数据库连接、文件等。

<资源争用>:
在一个线程占用一个排他性资源进行访问而未释放的时候，其他线程‘试图’访问该资源的现象。

<资源的调度>:
在多个线程申请同一个排他性资源的情况下，决定哪个线程会被授予该资源的独占权的过程。
资源调度策略的一个常见特性就是公平性。

<资源调度器>:
1.内部维护一个等待队列，申请失败的线程会被存入该队列。
2.当资源被持有线程释放时，等待队列中的一个线程会被选中并被唤醒而获得再次申请资源的机会。
3.被唤醒的线程如果申请到资源的独占权，那么该线程会从等待队列中移除；
否则，该线程仍然会停留在等待队列中等待再次申请的机会，即该线程会再次被暂停。

公平(FIFO):公平的调度策略不允许插队现象的出现。
只有在资源未被其他任何线程占用，并且等待队列为空的情况下，
资源的申请者才被允许<抢占>相应资源的独占权。

非公平:允许插队现象，即一个线程释放对资源的独占权时，
等待队列中的一个线程会被唤醒来再次申请相应的资源，
而在这个过程中另外一个申请该资源的活跃线程（生命周期状态为RUNNABLE状态）
可以与这个被唤醒的线程共同参与相应资源的抢占。
这时如果失败队列又一次失败，将有可能出现出现饥饿现象。
---------------------------------------------------------------------------------

调度器公平和非公平的区别:===========================================================
既然非公平调度策略有可能导致饥饿线程，那为什么还要提出这种调度策略呢？
这是因为，在公平调度策略中，当一个线程在申请资源时，
只要等待队列不为空，即存在在它之前的申请者，
那么这个线程一定会被暂停并加入等待队列，这就必然会出现线程的上下文切换。--------影响吞度量
而在非公平调度策略中，资源的持有线程释放资源的时候，等待队列中的一个线程会被唤醒，
新来的线程也会参与到资源的竞争当中。如果新来的线程申请到了资源，那么它就无需进行上下文切换。
如果这个新来的线程占用该资源的时间不长，那么它甚至有可能在被唤醒的线程继续其运行前释放资源，
从而不影响该被唤醒的线程申请资源。它可能会减少上下文切换的次数，从而提高吞吐率。
----------------------------------------------------------------------------------

